---
title: "Custom functions for the customer churn workflow"
output: html_document
---

# About

`targets` can watch input files, output files, and literate programming documents for changes. This chapter explores how to configure a target to automatically run when a file changes.

# Setup

Run `tar_destroy()` to remove the targets from the previous chapter.

```{r}
library(targets)
tar_destroy()
```

Load this chapter's quiz questions. Try not to peek in advance.

```{r}
source("R/quiz.R")
source("4-files/answers.R")
```

Run the following command to write the required `_targets.R` script to the your working directory.

```{r, echo = FALSE}
file.copy("4-files/initial_targets.R", "_targets.R", overwrite = TRUE)
```

Open `_targets.R` for editing

```{r}
library(usethis)
edit_file("_targets.R", open = TRUE)
```

# Review: input data files

As we saw in `3-changes.Rmd`, `targets` can watch files like `data/churn.csv` for changes. Let's review how this works. First, run the full pipeline from start to finish.

```{r}
tar_make()
```

Verify that all targets are now up to date.

```{r}
tar_make()
```

Now, open the customer churn data file for editing. Manually remove the last line of data in the file.

```{r}
edit_file("data/churn.csv")
```

When we call `tar_make()` again, all targets should rerun because they all depend on the upstream file target `churn_file`.

```{r}
tar_make()
```

How do we configure `churn_file` and downstream targets to rerun when `data/churn.csv` changes?

A. The target's return value needs to be a character vector of file and directory paths. These paths get resolved at runtime, so we do not need to know them before we call `tar_make()`. 
B. In `tar_target()`, set the `format` argument equal to `"file"`. That way, `tar_make()` knows the return value of `churn_file` is a bunch of file paths that need to be watched.
C. Targets directly downstream need to mention the symbol `churn_file` (as opposed to the literal path `"data/churn.csv"`) so `tar_make()` can discover the correct dependency relationships among targets. Always check with `tar_visnetwork()` to verify that your targets are connected properly in the dependency graph.
D. All the above.

```{r}
answer_review("E")
```

# Output files

In `targets`, we configure output files the exact same way. The only difference between input and output files is that output files are created when the target runs.

As an example, open `_targets.R` and create a new file targets `churn_cor`, which saves a plot of the correlation of each covariate with customer churn in the preprocessed testing data. Functions `compute_cor()` and `plot_cor()` in `4-files/functions.R` do most of the work.

```{r}
edit_file("_targets.R", open = TRUE)
```

Enter the new target below into `tar_pipeline()` in `_targets.R`.

```{r, eval = FALSE}
tar_target(
  churn_cor, {
    out <- plot_cor(compute_cor(churn_recipe))
    path <- "cor.png"
    ggsave(plot = out, filename = path, width = 8, height = 8)
    path # The return value must be the path to the file we write.
  },
  format = "file" # Tells targets to track the return value (path) as a file.
)
```

Run the pipeline. Since all previous targets are up to date, only `churn_cor` should run.

```{r}
tar_make()
```

What is the return value of the new `churn_cor` target?

```{r}
tar_read(churn_cor)
```

A. `"cor.png"`, the file path to the correlation plot.
B. A `ggplot` object with the correlation plot.
C. A data frame of correlations.
D. A function called `churn_cor()`.

```{r}
answer_return("E")
```

Take a look at the new output file `cor.png`. You should see a plot of each variable's correlation with customer churn.

Now, delete the file and rerun the pipeline.

```{r}
tmp <- file.remove("cor.png")
tar_make()
```

What happened? Why?

A. All targets reran because we changed a file.
B. No target reran because `targets` does not track the deleted file.
C. Because `churn_cor` is a correctly configured file target, `tar_make()` noticed when `cor.png` changed and automatically reran in order to repair the file.
D. `churn_cor` because `targets` always treats character strings as file names.

```{r}
answer_delete("E")
```

# Literate programming

